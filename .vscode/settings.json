{
  "editor.guides.bracketPairs": true,
  "editor.matchBrackets": "never",
  "cSpell.words": [
    "allowdeletebranch",
    "allowdeletetag",
    "allowmodifytag",
    "allownonascii",
    "allowunannotated",
    "basebranch",
    "bitsrc",
    "checkpatch",
    "CMDB",
    "cmdbadmin",
    "codepen",
    "commitmsg",
    "csswg",
    "debugbear",
    "denycreatebranch",
    "describedby",
    "devsec",
    "divless",
    "dnsadmin",
    "echoback",
    "engageable",
    "fieldset",
    "FIELDSETS",
    "Flexbox",
    "Frontends",
    "getbootstrap",
    "Googlebot",
    "H√•kon",
    "hostnames",
    "idmadmin",
    "inrhythm",
    "inte",
    "ishadeed",
    "jdoe",
    "Joomla",
    "Khronos",
    "lambdatest",
    "lockdown",
    "Magento",
    "mgit",
    "mgmt",
    "mjane",
    "Mj√∂lnir",
    "netops",
    "networkteam",
    "newrev",
    "oldrev",
    "oneline",
    "projectdesc",
    "QUIC",
    "reactiveness",
    "scriptable",
    "SDLC",
    "sdoe",
    "secadmin",
    "secops",
    "selectedcontent",
    "semrush",
    "sendemail",
    "SERP",
    "smashingmagazine",
    "spammy",
    "Stackblitz",
    "sustainabilityguide",
    "tabindex",
    "thenewstack",
    "tobiasahlin",
    "Wachowski",
    "WCAG",
    "WEBDX",
    "WHATWG",
    "Wium",
    "worktree"
  ],
  "files.exclude": {
    "**/.git": false
  },
  "window.autoDetectColorScheme": true,
  "workbench.preferredDarkColorTheme": "One Dark Pro Darker",
  "geminicodeassist.rules": "\n\n# D7460N Architecture Ruleset for Google Gemini Code Assistant\n\n## üéØ OVERVIEW\n> A zero-dependency, standards-based architecture using modern browser-native capabilities to declaratively model UI/UX logic without frameworks or JavaScript state management.\n\n## üß© CORE PRINCIPLES\n\n### 1. Declarative UI State via DOM Observability\n- UI state is inferred from **structure**, not tracked in code.\n- JS is **only** for data delivery.\n- CSS observes DOM structure and **controls all UI behavior**.\n\nExamples:\n- Use `:has()`, `:checked`, `:empty`, `[aria-*]` to reflect state.\n- Use `<details>`, `<input type=checkbox>`, `<fieldset>` for toggles/visibility.\n\n## üì¶ STRUCTURE RULES\n\n### 2. Semantic HTML Only\n- Use intrinsic elements like `<nav>`, `<section>`, `<article>`, `<aside>`, `<form>`, and `<ul><li>`.\n- Never use `<div>` or `<span>` unless no semantic alternative exists.\n\n### 3. No IDs or Classes\n- Selection should rely on **pure structure**, tag type, order, or attribute selectors.\n\n## üé® STYLING RULES\n\n### 4. CSS-Only Heuristics\n- All interactivity (loading indicators, tab views, detail panes) is modeled in CSS using `:has()` and boolean logic.\n\n### 5. Component Styling via Nesting\n- All selectors are **structurally scoped** to reflect actual layout.\n- Use `@layer heuristics;` to isolate behavioral logic.\n\n```css\napp-container > main > article:has(section:has(ul:not(:empty))) {\n  display: grid;\n}\n```\n\n### 6. Theme Control\n- All colors and theming must use `color-scheme` and `light-dark()` strategy.\n- Default theme follows dark colors (#233142, #FF5959).\n\n## üìä DATA LAYER RULES\n\n### 7. JSON-Only Data Source\n- JS fetches data from static or live JSON endpoints.\n- Data is inserted into pre-existing semantic HTML ‚Äî **never injected with structure**.\n\n### 8. Role-Based Rendering\n- Role access is determined by data content.\n- HTML contains all potential views; CSS reveals based on DOM structure.\n\n## üîç STATE & INTERACTION RULES\n\n### 9. No JS Event Listeners\n- No use of `addEventListener`, `.onclick`, or JS-based toggling.\n\n### 10. CSS Boolean Logic for UI State\n- State transitions (e.g. loading/fetched/empty/error) modeled using:\n  - checkbox toggles\n  - dynamic population detection via `:empty`\n  - nested DOM observability\n\n## üõÇ ACCESSIBILITY RULES\n\n### 11. 508/WCAG Conformance via Structure\n- All features must work with JavaScript disabled.\n- Use `aria-*`, keyboard-accessible elements, and correct heading order.\n\n### 12. No ARIA Workarounds\n- Accessibility is achieved through native semantics, not patched with ARIA roles.\n\n## üõ† INTEGRATION RULES FOR GEMINI\n\n- Prefer code completions that use `HTML + CSS` only.\n- Avoid offering frameworks (React, Angular, Vue) unless explicitly asked.\n- When generating code:\n  - Use `<section><ul><li>` instead of `<div class=\"list\">`.\n  - Detect and use existing `fieldset > label + input` instead of new markup.\n  - Prefer `input[type=checkbox]` to control UI states.\n- Ensure suggestions work **with screen readers, no JS, and keyboard navigation.**\n\n## üîÅ MAINTAINABILITY & DX RULES\n\n### 13. Separation of Concerns\n- JS: fetch data only.\n- HTML: structure only.\n- CSS: UI behavior, visibility, animation, and validation.\n\n### 14. Form Validation\n- Use `:invalid`, `:valid`, and `form:has(:valid)` to control submission heuristics.\n- No JS-based validation logic.\n\n## ‚úÖ VERIFICATION ROUTINE (for Gemini Compliance)\nBefore suggesting or completing code:\n1. ‚úÖ Is all interactivity handled in HTML/CSS?\n2. ‚úÖ Are all tags semantic and structure-based?\n3. ‚úÖ Does the UI reflect state via CSS selectors (`:has()`, `:checked`, etc.)?\n4. ‚úÖ Are all form states and toggles keyboard accessible?\n5. ‚úÖ Are no JavaScript UI interactions used?\n6. ‚úÖ Does this code work if JavaScript is disabled?"
}
